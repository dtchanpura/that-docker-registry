var app = (function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function callAfter(fn, i) {
		if (i === 0) fn();
		return () => {
			if (!--i) fn();
		};
	}

	function addLoc(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		fn();
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function toggleClass(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var protoDev = {
		destroy: destroyDev,
		get,
		fire,
		on,
		set: setDev,
		_recompute: noop,
		_set,
		_stage,
		_mount,
		_differs
	};

	/* src/ItemRow.html generated by Svelte v2.16.0 */

	const file = "src/ItemRow.html";

	function create_main_fragment(component, ctx) {
		var tr, td0, text0, text1, td1, code, text2, text3, text4, current;

		function click_handler(event) {
			component.fire('select', { repositoryName: ctx.repositoryName });
		}

		return {
			c: function create() {
				tr = createElement("tr");
				td0 = createElement("td");
				text0 = createText(ctx.repositoryName);
				text1 = createText("\n  ");
				td1 = createElement("td");
				code = createElement("code");
				text2 = createText(ctx.registryOrigin);
				text3 = createText("/");
				text4 = createText(ctx.repositoryName);
				addListener(td0, "click", click_handler);
				addLoc(td0, file, 1, 2, 7);
				addLoc(code, file, 2, 6, 85);
				addLoc(td1, file, 2, 2, 81);
				addLoc(tr, file, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td0);
				append(td0, text0);
				append(tr, text1);
				append(tr, td1);
				append(td1, code);
				append(code, text2);
				append(code, text3);
				append(code, text4);
				current = true;
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (changed.repositoryName) {
					setData(text0, ctx.repositoryName);
				}

				if (changed.registryOrigin) {
					setData(text2, ctx.registryOrigin);
				}

				if (changed.repositoryName) {
					setData(text4, ctx.repositoryName);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(tr);
				}

				removeListener(td0, "click", click_handler);
			}
		};
	}

	function ItemRow(options) {
		this._debugName = '<ItemRow>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('repositoryName' in this._state)) console.warn("<ItemRow> was created without expected data property 'repositoryName'");
		if (!('registryOrigin' in this._state)) console.warn("<ItemRow> was created without expected data property 'registryOrigin'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(ItemRow.prototype, protoDev);

	ItemRow.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/List.html generated by Svelte v2.16.0 */

	function data() {
		return {
			items: null,
			registryOrigin: null,
			descending: null,
			// orderBy: null // Not needed as only one column is present
		};
	}
	var methods = {
		sort() {
			const { items, descending } = this.get();
			if (!descending) {
				items.sort();
			} else {
				items.sort().reverse();
			}
			this.set({
				items: items,
				descending: !descending
			});
		}
	};

	async function oncreate() {
		var serverVersion = "";
		const { descending } = this.get();
		const response = await fetch(`/v2/_catalog`).then(function(r) {
		serverVersion = r.headers.get('Docker-Distribution-Api-Version');
			return r.json();
		});
		var items = response.repositories;
		this.fire('version', {version: serverVersion});
		this.set({
			registryOrigin: window.location.host,
			items: items
		});
	}
	const file$1 = "src/List.html";

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.repositoryName = list[i];
		return child_ctx;
	}

	function create_main_fragment$1(component, ctx) {
		var table, thead, tr, th0, text0, span, text1, th1, text3, tbody, current_block_type_index, if_block, current;

		function click_handler(event) {
			component.sort();
		}

		var if_block_creators = [
			create_if_block,
			create_else_block
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.items) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				table = createElement("table");
				thead = createElement("thead");
				tr = createElement("tr");
				th0 = createElement("th");
				text0 = createText("Tag ");
				span = createElement("span");
				text1 = createText("\n\t\t\t\t");
				th1 = createElement("th");
				th1.textContent = "Image Name";
				text3 = createText("\n\n\t\t");
				tbody = createElement("tbody");
				if_block.c();
				setStyle(span, "line-height", "1px");
				toggleClass(span, "hidden", ctx.descending == null);
				toggleClass(span, "arrow-down", ctx.descending);
				toggleClass(span, "arrow-up", !ctx.descending);
				addLoc(span, file$1, 3, 30, 78);
				addListener(th0, "click", click_handler);
				addLoc(th0, file$1, 3, 4, 52);
				addLoc(th1, file$1, 4, 4, 219);
				addLoc(tr, file$1, 2, 3, 43);
				addLoc(thead, file$1, 1, 2, 32);
				addLoc(tbody, file$1, 8, 2, 262);
				table.className = "u-full-width";
				addLoc(table, file$1, 0, 1, 1);
			},

			m: function mount(target, anchor) {
				insert(target, table, anchor);
				append(table, thead);
				append(thead, tr);
				append(tr, th0);
				append(th0, text0);
				append(th0, span);
				append(tr, text1);
				append(tr, th1);
				append(table, text3);
				append(table, tbody);
				if_blocks[current_block_type_index].m(tbody, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.descending) {
					toggleClass(span, "hidden", ctx.descending == null);
					toggleClass(span, "arrow-down", ctx.descending);
					toggleClass(span, "arrow-up", !ctx.descending);
				}

				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(tbody, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(table);
				}

				removeListener(th0, "click", click_handler);
				if_blocks[current_block_type_index].d();
			}
		};
	}

	// (16:3) {:else}
	function create_else_block(component, ctx) {
		var tr, td, current;

		return {
			c: function create() {
				tr = createElement("tr");
				td = createElement("td");
				td.textContent = "loading images...";
				td.colSpan = "2";
				addLoc(td, file$1, 16, 7, 514);
				addLoc(tr, file$1, 16, 3, 510);
			},

			m: function mount(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(tr);
				}
			}
		};
	}

	// (10:3) {#if items}
	function create_if_block(component, ctx) {
		var each_anchor, current;

		var each_value = ctx.items;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(() => {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) fn();
				});
			}
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(target, anchor);
				}

				insert(target, each_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.registryOrigin || changed.items) {
					each_value = ctx.items;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(each_anchor.parentNode, each_anchor);
					}
					for (; i < each_blocks.length; i += 1) outroBlock(i, 1);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				each_blocks = each_blocks.filter(Boolean);
				const countdown = callAfter(outrocallback, each_blocks.length);
				for (let i = 0; i < each_blocks.length; i += 1) outroBlock(i, 0, countdown);

				current = false;
			},

			d: function destroy$$1(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (11:3) {#each items as repositoryName}
	function create_each_block(component, ctx) {
		var current;

		var itemrow_initial_data = {
		 	registryOrigin: ctx.registryOrigin,
		 	repositoryName: ctx.repositoryName
		 };
		var itemrow = new ItemRow({
			root: component.root,
			store: component.store,
			data: itemrow_initial_data
		});

		itemrow.on("select", function(event) {
			component.fire('select', { repositoryName: ctx.repositoryName });
		});

		return {
			c: function create() {
				itemrow._fragment.c();
			},

			m: function mount(target, anchor) {
				itemrow._mount(target, anchor);
				current = true;
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				var itemrow_changes = {};
				if (changed.registryOrigin) itemrow_changes.registryOrigin = ctx.registryOrigin;
				if (changed.items) itemrow_changes.repositoryName = ctx.repositoryName;
				itemrow._set(itemrow_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (itemrow) itemrow._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy$$1(detach) {
				itemrow.destroy(detach);
			}
		};
	}

	function List(options) {
		this._debugName = '<List>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign(data(), options.data);
		if (!('descending' in this._state)) console.warn("<List> was created without expected data property 'descending'");
		if (!('items' in this._state)) console.warn("<List> was created without expected data property 'items'");
		if (!('registryOrigin' in this._state)) console.warn("<List> was created without expected data property 'registryOrigin'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$1(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(List.prototype, protoDev);
	assign(List.prototype, methods);

	List.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/Tag.html generated by Svelte v2.16.0 */

	async function oncreate$1() {
	  const {
	    tag
	  } = this.get();
	  // ref: https://stackoverflow.com/a/52810852/4414721
	  const now = new Date();
	  const times = [
	    ["second", 1],
	    ["minute", 60],
	    ["hour", 3600],
	    ["day", 86400],
	    ["week", 604800],
	    ["month", 2592000],
	    ["year", 31536000]
	  ];
	  var diff = Math.round((now - tag.createdAt) / 1000);
	  for (var t = 0; t < times.length; t++) {
	    if (diff < times[t][1]) {
	      if (t == 0) {
	        tag.sinceTime = "Just now";
	        this.set({
	          tag
	        });
	        return;
	      } else {
	        diff = Math.round(diff / times[t - 1][1]);
	        tag.sinceTime = diff + " " + times[t - 1][0] + (diff == 1 ? " ago" : "s ago");
	        this.set({
	          tag
	        });
	        return;
	      }
	    }
	  }
	}
	const file$2 = "src/Tag.html";

	function create_main_fragment$2(component, ctx) {
		var tr, current;

		function select_block_type(ctx) {
			if (ctx.tag) return create_if_block$1;
			return create_else_block$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				tr = createElement("tr");
				if_block.c();
				addLoc(tr, file$2, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, tr, anchor);
				if_block.m(tr, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(tr, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(tr);
				}

				if_block.d();
			}
		};
	}

	// (7:2) {:else}
	function create_else_block$1(component, ctx) {
		var td;

		return {
			c: function create() {
				td = createElement("td");
				td.textContent = "...";
				addLoc(td, file$2, 7, 2, 235);
			},

			m: function mount(target, anchor) {
				insert(target, td, anchor);
			},

			p: noop,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(td);
				}
			}
		};
	}

	// (2:2) {#if tag}
	function create_if_block$1(component, ctx) {
		var td0, text0_value = ctx.tag.repositoryName, text0, text1, td1, code0, text2_value = ctx.tag.tagName, text2, text3, td2, code1, text4_value = ctx.tag.imageID.substr(7,12), text4, td2_title_value, text5, td3, text6_value = ctx.tag.sinceTime, text6, td3_title_value;

		return {
			c: function create() {
				td0 = createElement("td");
				text0 = createText(text0_value);
				text1 = createText("\n  ");
				td1 = createElement("td");
				code0 = createElement("code");
				text2 = createText(text2_value);
				text3 = createText("\n  ");
				td2 = createElement("td");
				code1 = createElement("code");
				text4 = createText(text4_value);
				text5 = createText("\n  ");
				td3 = createElement("td");
				text6 = createText(text6_value);
				addLoc(td0, file$2, 2, 2, 19);
				addLoc(code0, file$2, 3, 6, 57);
				addLoc(td1, file$2, 3, 2, 53);
				addLoc(code1, file$2, 4, 30, 121);
				td2.title = td2_title_value = ctx.tag.imageID;
				addLoc(td2, file$2, 4, 2, 93);
				td3.title = td3_title_value = ctx.tag.createdAt;
				addLoc(td3, file$2, 5, 2, 170);
			},

			m: function mount(target, anchor) {
				insert(target, td0, anchor);
				append(td0, text0);
				insert(target, text1, anchor);
				insert(target, td1, anchor);
				append(td1, code0);
				append(code0, text2);
				insert(target, text3, anchor);
				insert(target, td2, anchor);
				append(td2, code1);
				append(code1, text4);
				insert(target, text5, anchor);
				insert(target, td3, anchor);
				append(td3, text6);
			},

			p: function update(changed, ctx) {
				if ((changed.tag) && text0_value !== (text0_value = ctx.tag.repositoryName)) {
					setData(text0, text0_value);
				}

				if ((changed.tag) && text2_value !== (text2_value = ctx.tag.tagName)) {
					setData(text2, text2_value);
				}

				if ((changed.tag) && text4_value !== (text4_value = ctx.tag.imageID.substr(7,12))) {
					setData(text4, text4_value);
				}

				if ((changed.tag) && td2_title_value !== (td2_title_value = ctx.tag.imageID)) {
					td2.title = td2_title_value;
				}

				if ((changed.tag) && text6_value !== (text6_value = ctx.tag.sinceTime)) {
					setData(text6, text6_value);
				}

				if ((changed.tag) && td3_title_value !== (td3_title_value = ctx.tag.createdAt)) {
					td3.title = td3_title_value;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(td0);
					detachNode(text1);
					detachNode(td1);
					detachNode(text3);
					detachNode(td2);
					detachNode(text5);
					detachNode(td3);
				}
			}
		};
	}

	function Tag(options) {
		this._debugName = '<Tag>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('tag' in this._state)) console.warn("<Tag> was created without expected data property 'tag'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$2(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$1.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Tag.prototype, protoDev);

	Tag.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ItemDetail.html generated by Svelte v2.16.0 */

	function data$1() {
	  return {
	    tags: null,
	    descending: null,
	    orderBy: null
	  };
	}
	var methods$1 = {
	  sort(column) {
	    const { tags, descending, orderBy } = this.get();
	    var toggle = true;
	    if (descending && column == orderBy) {
	      toggle = false;
	    }
	    tags.sort(function(a, b) {
	      return toggle ? b[column] > a[column] : b[column] <= a[column]
	    });
	    this.set({
	      tags: tags,
	      orderBy: column,
	      descending: toggle
	    });
	    // console.log(this.get());
	  }
	};

	async function oncreate$2() {
	  const tags = [];
	  var serverVersion = "";
	  const {
	    repositoryName
	  } = this.get();
	  const response = await fetch(`/v2/` + repositoryName + '/tags/list')
	    .then(function(r) {
	      serverVersion = r.headers.get('Docker-Distribution-Api-Version');
	      console.log(serverVersion);
	      return r.json();
	    });
	  // .then(r => r.json());
	  // response.tags.forEach(function(tag) {
	  for (var i = 0; i < response.tags.length; i++) {
	    const tag = response.tags[i];
	    const responseLate = await fetch('/v2/' + repositoryName + '/manifests/' + tag, {
	        "headers": {
	          "Accept": "application/vnd.docker.distribution.manifest.v2+json"
	        }
	      })
	      .then(r => r.json())
	      .then(function(tagManifest) {
	        return fetch('/v2/' + repositoryName + '/blobs/' + tagManifest.config.digest, {
	            "headers": {
	              "Accept": tagManifest.config.mediaType
	            }
	          })
	          .then(r => r.json())
	          .then(function(tagBlobData) {
	            var tagElement = {
	              "tagName": tag,
	              "repositoryName": repositoryName,
	              "imageID": tagManifest.config.digest, // full image ID
	              "createdAt": new Date(tagBlobData.created)
	            };
	            tags.push(tagElement);
	            return tagElement;
	          }) // fetch Tag Blob
	      }); // fetch Tag manifest
	  } // For loop
	  // }) // forEach
	  // }) // fetch Tag List

	  // Set values to component
	  this.fire('version', {
	    version: serverVersion
	  });
	  this.set({
	    tags: tags,
	  });
	}
	const file$3 = "src/ItemDetail.html";

	function get_each_context$1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.tag = list[i];
		return child_ctx;
	}

	function create_main_fragment$3(component, ctx) {
		var button, span0, text0, text1, table, thead, tr, th0, text3, th1, text4, span1, text5, th2, text6, span2, text7, th3, text8, span3, text9, tbody, current_block_type_index, if_block, current;

		function click_handler(event) {
			component.fire('select', null);
		}

		function click_handler_1(event) {
			component.sort('tagName');
		}

		function click_handler_2(event) {
			component.sort('imageID');
		}

		function click_handler_3(event) {
			component.sort('createdAt');
		}

		var if_block_creators = [
			create_if_block$2,
			create_else_block$2
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.tags) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				button = createElement("button");
				span0 = createElement("span");
				text0 = createText(" Back");
				text1 = createText("\n\n");
				table = createElement("table");
				thead = createElement("thead");
				tr = createElement("tr");
				th0 = createElement("th");
				th0.textContent = "Image Name";
				text3 = createText("\n      ");
				th1 = createElement("th");
				text4 = createText("Tag ");
				span1 = createElement("span");
				text5 = createText("\n      ");
				th2 = createElement("th");
				text6 = createText("Image ID ");
				span2 = createElement("span");
				text7 = createText("\n      ");
				th3 = createElement("th");
				text8 = createText("Created at ");
				span3 = createElement("span");
				text9 = createText("\n\n  ");
				tbody = createElement("tbody");
				if_block.c();
				span0.className = "arrow-left";
				addLoc(span0, file$3, 1, 83, 133);
				addListener(button, "click", click_handler);
				button.className = "button";
				setStyle(button, "font-weight", "bolder");
				addLoc(button, file$3, 1, 0, 50);
				addLoc(th0, file$3, 6, 6, 235);
				setStyle(span1, "line-height", "1px");
				toggleClass(span1, "hidden", ctx.orderBy != 'tagName');
				toggleClass(span1, "arrow-down", ctx.descending);
				toggleClass(span1, "arrow-up", !ctx.descending);
				addLoc(span1, file$3, 7, 41, 296);
				addListener(th1, "click", click_handler_1);
				addLoc(th1, file$3, 7, 6, 261);
				toggleClass(span2, "hidden", ctx.orderBy != 'imageID');
				toggleClass(span2, "arrow-down", ctx.descending);
				toggleClass(span2, "arrow-up", !ctx.descending);
				addLoc(span2, file$3, 8, 46, 481);
				addListener(th2, "click", click_handler_2);
				addLoc(th2, file$3, 8, 6, 441);
				toggleClass(span3, "hidden", ctx.orderBy != 'createdAt');
				toggleClass(span3, "arrow-down", ctx.descending);
				toggleClass(span3, "arrow-up", !ctx.descending);
				addLoc(span3, file$3, 9, 50, 645);
				addListener(th3, "click", click_handler_3);
				addLoc(th3, file$3, 9, 6, 601);
				addLoc(tr, file$3, 5, 4, 224);
				addLoc(thead, file$3, 4, 2, 212);
				addLoc(tbody, file$3, 13, 2, 785);
				table.className = "u-full-width";
				addLoc(table, file$3, 3, 0, 181);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
				append(button, span0);
				append(button, text0);
				insert(target, text1, anchor);
				insert(target, table, anchor);
				append(table, thead);
				append(thead, tr);
				append(tr, th0);
				append(tr, text3);
				append(tr, th1);
				append(th1, text4);
				append(th1, span1);
				append(tr, text5);
				append(tr, th2);
				append(th2, text6);
				append(th2, span2);
				append(tr, text7);
				append(tr, th3);
				append(th3, text8);
				append(th3, span3);
				append(table, text9);
				append(table, tbody);
				if_blocks[current_block_type_index].m(tbody, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.orderBy) {
					toggleClass(span1, "hidden", ctx.orderBy != 'tagName');
				}

				if (changed.descending) {
					toggleClass(span1, "arrow-down", ctx.descending);
					toggleClass(span1, "arrow-up", !ctx.descending);
				}

				if (changed.orderBy) {
					toggleClass(span2, "hidden", ctx.orderBy != 'imageID');
				}

				if (changed.descending) {
					toggleClass(span2, "arrow-down", ctx.descending);
					toggleClass(span2, "arrow-up", !ctx.descending);
				}

				if (changed.orderBy) {
					toggleClass(span3, "hidden", ctx.orderBy != 'createdAt');
				}

				if (changed.descending) {
					toggleClass(span3, "arrow-down", ctx.descending);
					toggleClass(span3, "arrow-up", !ctx.descending);
				}

				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(tbody, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
				if (detach) {
					detachNode(text1);
					detachNode(table);
				}

				removeListener(th1, "click", click_handler_1);
				removeListener(th2, "click", click_handler_2);
				removeListener(th3, "click", click_handler_3);
				if_blocks[current_block_type_index].d();
			}
		};
	}

	// (20:4) {:else}
	function create_else_block$2(component, ctx) {
		var tr, td0, text1, td1, code0, text3, td2, code1, text5, td3, text6_value = new ctx.Date(0), text6, current;

		return {
			c: function create() {
				tr = createElement("tr");
				td0 = createElement("td");
				td0.textContent = "loading tags...";
				text1 = createText("\n      ");
				td1 = createElement("td");
				code0 = createElement("code");
				code0.textContent = "...";
				text3 = createText("\n      ");
				td2 = createElement("td");
				code1 = createElement("code");
				code1.textContent = "000000000000";
				text5 = createText("\n      ");
				td3 = createElement("td");
				text6 = createText(text6_value);
				addLoc(td0, file$3, 21, 6, 933);
				addLoc(code0, file$3, 22, 10, 968);
				addLoc(td1, file$3, 22, 6, 964);
				addLoc(code1, file$3, 23, 10, 1000);
				addLoc(td2, file$3, 23, 6, 996);
				addLoc(td3, file$3, 24, 6, 1037);
				addLoc(tr, file$3, 20, 4, 922);
			},

			m: function mount(target, anchor) {
				insert(target, tr, anchor);
				append(tr, td0);
				append(tr, text1);
				append(tr, td1);
				append(td1, code0);
				append(tr, text3);
				append(tr, td2);
				append(td2, code1);
				append(tr, text5);
				append(tr, td3);
				append(td3, text6);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.Date) && text6_value !== (text6_value = new ctx.Date(0))) {
					setData(text6, text6_value);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(tr);
				}
			}
		};
	}

	// (15:4) {#if tags}
	function create_if_block$2(component, ctx) {
		var each_anchor, current;

		var each_value = ctx.tags;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(() => {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) fn();
				});
			}
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(target, anchor);
				}

				insert(target, each_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.tags) {
					each_value = ctx.tags;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(each_anchor.parentNode, each_anchor);
					}
					for (; i < each_blocks.length; i += 1) outroBlock(i, 1);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				each_blocks = each_blocks.filter(Boolean);
				const countdown = callAfter(outrocallback, each_blocks.length);
				for (let i = 0; i < each_blocks.length; i += 1) outroBlock(i, 0, countdown);

				current = false;
			},

			d: function destroy$$1(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (16:4) {#each tags as tag}
	function create_each_block$1(component, ctx) {
		var text, current;

		var tag_initial_data = { tag: ctx.tag };
		var tag = new Tag({
			root: component.root,
			store: component.store,
			data: tag_initial_data
		});

		return {
			c: function create() {
				tag._fragment.c();
				text = createText("\n    ");
			},

			m: function mount(target, anchor) {
				tag._mount(target, anchor);
				insert(target, text, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var tag_changes = {};
				if (changed.tags) tag_changes.tag = ctx.tag;
				tag._set(tag_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (tag) tag._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy$$1(detach) {
				tag.destroy(detach);
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	function ItemDetail(options) {
		this._debugName = '<ItemDetail>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign(assign({ Date : Date }, data$1()), options.data);
		if (!('orderBy' in this._state)) console.warn("<ItemDetail> was created without expected data property 'orderBy'");
		if (!('descending' in this._state)) console.warn("<ItemDetail> was created without expected data property 'descending'");
		if (!('tags' in this._state)) console.warn("<ItemDetail> was created without expected data property 'tags'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$3(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$2.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(ItemDetail.prototype, protoDev);
	assign(ItemDetail.prototype, methods$1);

	ItemDetail.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/App.html generated by Svelte v2.16.0 */



	var methods$2 = {
		// This is a simple router which changes view based on isList variable
		itemDetails(item) {
			console.log(item);
			this.set({
				isList: false,
				repositoryName: item
			});
		},
		version(version) {
			this.set({
				version: version
			});
		},
		close() {
			this.set({
				isList: true
			});
		}
	};

	const file$4 = "src/App.html";

	function create_main_fragment$4(component, ctx) {
		var title_value, text0, div6, div2, div0, h10, text1, text2, div1, h11, text3, text4, div3, current_block_type_index, if_block, text5, div5, div4, text6, code0, text7, text8, code1, text9, current;

		document.title = title_value = ctx.appTitle;

		var if_block_creators = [
			create_if_block$3,
			create_else_block$3
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.isList) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				text0 = createText("\n\n");
				div6 = createElement("div");
				div2 = createElement("div");
				div0 = createElement("div");
				h10 = createElement("h1");
				text1 = createText(ctx.name);
				text2 = createText("\n\t\t");
				div1 = createElement("div");
				h11 = createElement("h1");
				text3 = createText(ctx.subtitle);
				text4 = createText("\n\t");
				div3 = createElement("div");
				if_block.c();
				text5 = createText("\n\n\t");
				div5 = createElement("div");
				div4 = createElement("div");
				text6 = createText("Registry Version: ");
				code0 = createElement("code");
				text7 = createText(ctx.version);
				text8 = createText("\n\t\t\tUI Version: ");
				code1 = createElement("code");
				text9 = createText(ctx.uiVersion);
				addLoc(h10, file$4, 7, 3, 131);
				div0.className = "six columns";
				addLoc(div0, file$4, 6, 2, 102);
				addLoc(h11, file$4, 10, 3, 187);
				div1.className = "six columns";
				addLoc(div1, file$4, 9, 2, 158);
				div2.className = "row";
				addLoc(div2, file$4, 5, 1, 82);
				div3.className = "row";
				addLoc(div3, file$4, 13, 1, 225);
				addLoc(code0, file$4, 25, 21, 679);
				addLoc(code1, file$4, 26, 15, 717);
				div4.className = "version-footer";
				addLoc(div4, file$4, 24, 2, 629);
				div5.className = "row";
				addLoc(div5, file$4, 23, 1, 609);
				div6.className = "container";
				addLoc(div6, file$4, 4, 0, 57);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, div6, anchor);
				append(div6, div2);
				append(div2, div0);
				append(div0, h10);
				append(h10, text1);
				append(div2, text2);
				append(div2, div1);
				append(div1, h11);
				append(h11, text3);
				append(div6, text4);
				append(div6, div3);
				if_blocks[current_block_type_index].m(div3, null);
				append(div6, text5);
				append(div6, div5);
				append(div5, div4);
				append(div4, text6);
				append(div4, code0);
				append(code0, text7);
				append(div4, text8);
				append(div4, code1);
				append(code1, text9);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((!current || changed.appTitle) && title_value !== (title_value = ctx.appTitle)) {
					document.title = title_value;
				}

				if (!current || changed.name) {
					setData(text1, ctx.name);
				}

				if (!current || changed.subtitle) {
					setData(text3, ctx.subtitle);
				}

				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(div3, null);
				}

				if (!current || changed.version) {
					setData(text7, ctx.version);
				}

				if (!current || changed.uiVersion) {
					setData(text9, ctx.uiVersion);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(div6);
				}

				if_blocks[current_block_type_index].d();
			}
		};
	}

	// (18:2) {:else}
	function create_else_block$3(component, ctx) {
		var current;

		var itemdetail_initial_data = { repositoryName: ctx.repositoryName };
		var itemdetail = new ItemDetail({
			root: component.root,
			store: component.store,
			data: itemdetail_initial_data
		});

		itemdetail.on("version", function(event) {
			component.version(event.version);
		});
		itemdetail.on("select", function(event) {
			component.close();
		});

		return {
			c: function create() {
				itemdetail._fragment.c();
			},

			m: function mount(target, anchor) {
				itemdetail._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var itemdetail_changes = {};
				if (changed.repositoryName) itemdetail_changes.repositoryName = ctx.repositoryName;
				itemdetail._set(itemdetail_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (itemdetail) itemdetail._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy$$1(detach) {
				itemdetail.destroy(detach);
			}
		};
	}

	// (15:2) {#if isList}
	function create_if_block$3(component, ctx) {
		var current;

		var list = new List({
			root: component.root,
			store: component.store
		});

		list.on("version", function(event) {
			component.version(event.version);
		});
		list.on("select", function(event) {
			component.itemDetails(event.repositoryName);
		});

		return {
			c: function create() {
				list._fragment.c();
			},

			m: function mount(target, anchor) {
				list._mount(target, anchor);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (list) list._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy$$1(detach) {
				list.destroy(detach);
			}
		};
	}

	function App(options) {
		this._debugName = '<App>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('appTitle' in this._state)) console.warn("<App> was created without expected data property 'appTitle'");
		if (!('name' in this._state)) console.warn("<App> was created without expected data property 'name'");
		if (!('subtitle' in this._state)) console.warn("<App> was created without expected data property 'subtitle'");
		if (!('isList' in this._state)) console.warn("<App> was created without expected data property 'isList'");
		if (!('repositoryName' in this._state)) console.warn("<App> was created without expected data property 'repositoryName'");
		if (!('version' in this._state)) console.warn("<App> was created without expected data property 'version'");
		if (!('uiVersion' in this._state)) console.warn("<App> was created without expected data property 'uiVersion'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$4(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(App.prototype, protoDev);
	assign(App.prototype, methods$2);

	App.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	var version = "1.2.0-dev";

	const app = new App({
		target: document.body,
		data: {
			name: 'That Docker Registry',
			subtitle: '',
			item: null,
			isList: true,
			appTitle: "That Docker Registry",
			repositoryName: null,
			version: "0.0",
			uiVersion: version
		}
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
